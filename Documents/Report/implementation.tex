

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
\label{sec:implementation}
We intend to emulate our system in Mininet~\cite{mininet} to observe traffic 
patterns and infer a suitable token algorithm. Mininet has proven itself to be 
a viable tool to model new congestion control 
algorithms~\cite{mininet_learning}, and will help us prototype our concept 
efficiently. We will build a custom SDN controller that interacts with 
traditional OpenFlow software switches as well as end-hosts. End-hosts will run 
a custom real-world traffic generation script which adjusts based on 
information packets sent by the controller.
If time permits, we may expand our implementation to MaxiNet, which can emulate 
large-scale network stress tests on multiple physical hosts.

We initially considered a second implementation alternative in C/C++ based on 
the FastPass~\cite{fastpass} source code. This would provide us with a fully 
deployable system which we could fork our implementation from. A major 
advantage of this approach is the ability to test scenarios and traffic 
algorithms using real software code.
However, several concerns made us favour a Mininet emulation instead.
Firstly, FastPass relies on DPDK integration, which requires actual hardware 
interfaces. The central arbiter in the FastPass design would need to run on a 
dedicated machine, which increases prototyping and development complexity 
substantially.

Secondly, the FastPass code is highly specialized and optimized research code 
with only little available documentation. Modifying and evolving the source 
code will require thorough understanding of kernel and networking development, 
a significant time-sink. For a class project, these may be major initial 
hurdles, taking away from the research aspect of the design concept.
Consequently, we have decided to pursue an approach which allows us to quickly 
develop an understanding of the problem without being obstructed by engineering 
work.

